# 생각 순서..

- 점수를 입력받아 하나하나 접근
- 같은 점수가 입력될 경우 높은 등수로 동일 처리
- # 입력된 순서대로 등수를 출력 <br/>
- 1. 5개의 원소가 담긴 배열을 입력받아 각각의 등수를 출력하므로 answer를 배열로 초기화
- 2. 반복문을 돌려서 점수가 담겨져있는 배열 원소 하나하나에 접근.
- 3. 각 점수의 등수를 표현해야 하기때문에 최대값을 표현할 변수 하나를 선언 해야겠다..
- 4. ..... 이미 반복문을 돌아서 이미 결과가 담긴 원소에 대한 등수를 어떻게 바꾸지.......??

=================================================================

##### 1) ........ 등수를 표현하는 변수를 사용한다??????????? => rank

- 반복문 안에 if문을 돌려
- if문안에 arr[i]의 값이 최대값을 표현하는 변수 max와 비교해 max보다 크다면 ...<br/>
  max에 arr[i]의 값을 담고 arr[i]의 등수를 rank = 1
  작다면 arr[i]의 등수를 rank + 1
- ..........이렇게 해도 이미 들어간 값을 바꾸기가......

===================================================================

##### 2) ..... 반복문을 두개 돌려서 기준이 되는 값을 정해서 등수 올리기..?

- arr의 배열 원소 하나를 잡아서 그 다음 위치한 원소들을 비교.....?
- 우선 answer에 입력받는 arr의 배열길이만큼 answer에도 1 로 초기화
- 기준이 되는 배열의 원소 : arr[i] 그 다음 나머지 원소들을 비교하기위한 : arr[j]
- 예를들어, <br/>
  arr[0] -> arr[0], arr[1], arr[2], arr[3], arr[4] <br/>
  arr[1] -> arr[0], arr[1], arr[2], arr[3], arr[4] <br/>
  . <br/>
  . <br/>
  . <br/>
- 이 안에 answer값을 변화시킬 조건문을 넣는다.
- 기준이 되는 값이 비교되는 값보다 작을 경우 answer에 넣는 값을 하나 증가시킨다.
- .... 오호이!!!!!!!!!!!!!!!!!!

====================================================================================

# Array.from()

## 구문

    Array.from(arrayLike[, mapFn[, thisArg]])

<br/>

### 매개변수

- arrayLike : 배열로 변환하고자 하는 유사 배열 객체나 반복 가능한 객체. <br/><br/>

- mapFn(Optional) : 배열의 모든 요소에 대해 호출할 맵핑 함수. <br/><br/>

- thisArg(Optional) : mapFn 실행 시에 this로 사용할 값. <br/><br/>

### 반환 값

- 새로운 Array 인스턴스.

## 설명

다음과 같은 경우에 Array.from()으로새Array를 만들 수 있습니다. <br/>

- 유사 배열 객체 (length 속성과 인덱싱 된 요소를 가진 객체)
- 순회 가능한 객체 (en-US) (Map, Set 등객체의 요소를 얻을 수 있는 객체) <br/><br/>

Array.from()은 선택 매개변수인 mapFn를 가지는데, <br/>
배열(혹은 배열 서브클래스)의 각 요소를 맵핑할 때 사용할 수 있습니다. <br/>
즉,Array.from(obj, mapFn, thisArg)는 중간에 다른 배열을 생성하지 않는다는 점을 제외하면 <br/>
Array.from(obj).map(mapFn, thisArg)와 같습니다. <br/>
이 특징은 typed arrays와 같은 특정 배열 서브클래스에서 <br/>
중간 배열 값이 적절한 유형에 맞게 생략되기 때문에 특히 중요합니다.<br/><br/>

from() 메서드의 length 속성은 1입니다. <br/><br/>

ES2015 이후, 클래스 구문은 내장 및 새 클래스의 상속을 가능케 했습니다. <br/>
그 결과로 Array.from과 같은 정적 메서드는 Array의 서브클래스에 의해 상속되며, <br/>
Array 대신 자신의 인스턴스를 만듭니다.

##### 예제

- String에서 배열 만들기 <br/>
  Array.from('foo'); <br/>
  // ["f", "o", "o"] => from 메서드의 length 속성은 1이기 때문에 문자 하나하나씩을 원소로 갖는다<br/><br/>

- Set에서 배열 만들기 <br/>
  const s = new Set(['foo', window]); <br/>
  Array.from(s); <br/>
  // ["foo", window] <br/><br/>

- Map에서 배열 만들기 <br/>
  const m = new Map([[1, 2], [2, 4], [4, 8]]); <br/>
  Array.from(m); <br/>
  // [[1, 2], [2, 4], [4, 8]] <br/><br/>

const mapper = new Map([['1', 'a'], ['2', 'b']]); <br/>
Array.from(mapper.values()); <br/>
// ['a', 'b']; <br/><br/>

Array.from(mapper.keys()); <br/>
// ['1', '2']; <br/><br/>

- 배열 형태를 가진 객체(arguments)에서 배열 만들기
  function f() { <br/>
  return Array.from(arguments); <br/>
  } <br/><br/>

f(1, 2, 3); <br/>

// [1, 2, 3] <br/><br/>

- Array.from과 화살표 함수 사용하기
  // 화살표 기능을 지도 기능으로 사용하여 <br/>
  // 각각의 요소를 조작한다. <br/>
  Array.from([1, 2, 3], x => x + x); <br/>
  // [2, 4, 6] <br/><br/>

// 일련의 숫자를 생성<br/>
// 배열은 각 위치에 'undefined'로 초기화 되기 때문에, <br/>
// 아래의 'v'값은 '정의되지 않음' <br/>
Array.from({length: 5}, (v, i) => i); <br/>
// [0, 1, 2, 3, 4] <br/>
